<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="icon" href="data:,">
  <title>Objectiv</title>
  <link rel="stylesheet" href="src/styles.css">
  <script src="https://unpkg.com/lucide@latest"></script>
  <script type="module" src="src/app.js"></script>
</head>
<body>
  <!-- PIN Protection Modal -->
  <div id="pin-modal" class="modal-overlay">
    <div class="modal-content">
      <h2 style="margin: 0 0 16px 0; color: #e0e0e0;">Enter PIN</h2>
      <input type="password" id="pin-input" placeholder="••••" maxlength="4"
             style="width: 120px; padding: 12px; font-size: 24px; text-align: center;
                    background: #1a1a1a; border: 1px solid #333; color: #e0e0e0;
                    border-radius: 4px; letter-spacing: 8px;"
             autocomplete="off" />
      <div id="pin-error" style="color: #ff5555; margin-top: 8px; font-size: 12px; display: none;">Incorrect PIN</div>
    </div>
  </div>

  <!-- Titlebar -->
  <div id="titlebar">
    <div id="titlebar-title"></div>
    <div id="window-controls">
      <button class="window-btn" id="btn-toggle-sidebar" title="Toggle sidebar"><i data-lucide="panel-left"></i></button>
      <button class="window-btn" id="btn-minimize">&#xE921;</button>
      <button class="window-btn" id="btn-maximize">&#xE922;</button>
      <button class="window-btn close" id="btn-close">&#xE8BB;</button>
    </div>
  </div>

  <!-- Content Wrapper -->
  <div id="content-wrapper">
    <!-- Intro Screen -->
    <div id="intro">
      <div style="text-align: center;">
        <div><span id="intro-text"></span><span id="intro-cursor"></span></div>
        <div id="intro-tagline" style="color: #e0e0e0; font-size: 0.8rem; margin-top: 8px; opacity: 0;"></div>
      </div>
    </div>

    <!-- Main App - Split Pane -->
    <div id="app">
      <!-- Side List (1/3) -->
      <div id="side-list">
        <div id="resize-handle"></div>
        <div id="side-list-items"></div>
      </div>

      <!-- Content View (2/3) -->
      <div id="content-view">
        <!-- Mobile Header with Back Button -->
        <div class="mobile-header">
          <button class="mobile-back-btn" id="btn-mobile-back" aria-label="Back to objectives">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                 stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
          </button>
        </div>
        <div id="content-page">
          <div id="content-header">
            <div id="content-header-title">Select an objective</div>
            <div id="content-header-description"></div>
          </div>
          <div id="content-body"></div>
        </div>
      </div>
    </div>

    <!-- Status Bar -->
    <div id="status-bar">
      <div id="shortcuts"></div>
    </div>

    <!-- Message Toast -->
    <div id="message-toast"></div>

    <!-- Status Reporter -->
    <button class="status-toggle" id="status-toggle">inspect</button>
    <div id="status-reporter">
      <div class="status-title">System Status <span id="status-close" style="float:right;cursor:pointer;color:#666;">[x]</span></div>
      <div id="status-items"></div>
    </div>
  </div>

  <!-- Theme Toggle (direct child of body, before scripts) -->
  <button id="theme-toggle" title="Toggle theme">☀</button>

  <script>
    // ========================================
    // PLATFORM DETECTION & STATUS REPORTER
    // ========================================
    const isElectron = !!(window.electronAPI);
    const isBrowser = !isElectron;

    // Status tracking
    const systemStatus = {
      platform: isBrowser ? 'browser' : 'electron',
      localStorage: false,
      taglines: false,
      clarityAPI: false,
      errors: []
    };

    // Apply browser mode class
    if (isBrowser) {
      document.body.classList.add('browser-mode');
    }

    // ========================================
    // PIN PROTECTION
    // ========================================
    const APP_PIN = '2298';
    const PIN_AUTH_KEY = 'objectiv-authenticated';

    (function initPinProtection() {
      const pinModal = document.getElementById('pin-modal');
      const pinInput = document.getElementById('pin-input');
      const pinError = document.getElementById('pin-error');

      // Check if already authenticated (persists in browser cache)
      if (localStorage.getItem(PIN_AUTH_KEY) === 'true') {
        pinModal.style.display = 'none';
        return;
      }

      // Show modal and focus input
      pinModal.style.display = 'flex';
      setTimeout(() => pinInput.focus(), 100);

      // Handle PIN input
      pinInput.addEventListener('input', () => {
        pinError.style.display = 'none';
        if (pinInput.value.length === 4) {
          if (pinInput.value === APP_PIN) {
            localStorage.setItem(PIN_AUTH_KEY, 'true');
            pinModal.style.display = 'none';
          } else {
            pinError.style.display = 'block';
            pinInput.value = '';
            pinInput.focus();
          }
        }
      });

      // Handle Enter key
      pinInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && pinInput.value.length === 4) {
          if (pinInput.value === APP_PIN) {
            localStorage.setItem(PIN_AUTH_KEY, 'true');
            pinModal.style.display = 'none';
          } else {
            pinError.style.display = 'block';
            pinInput.value = '';
          }
        }
      });
    })();

    // Theme toggle
    (function() {
      const toggle = document.getElementById('theme-toggle');
      const stored = localStorage.getItem('objectiv-theme');
      if (stored === 'light') {
        document.body.classList.add('light-mode');
        toggle.textContent = '☾';
      }
      toggle.addEventListener('click', () => {
        const isLight = document.body.classList.toggle('light-mode');
        toggle.textContent = isLight ? '☾' : '☀';
        localStorage.setItem('objectiv-theme', isLight ? 'light' : 'dark');
      });
    })();

    // Status reporter functions
    function updateStatusReporter() {
      const container = document.getElementById('status-items');
      if (!container) return;

      // Get Supabase storage status
      const storageStatus = window.Objectiv?.Repository?.getStorageStatus?.() || { isReady: false };
      const storageLabel = storageStatus.isReady ? 'connected' : 'not configured';
      const storageSt = storageStatus.isReady ? 'ok' : 'warn';

      const items = [
        { label: 'Platform', value: 'web', status: 'ok' },
        { label: 'Supabase', value: storageLabel, status: storageSt },
        { label: 'Taglines', value: systemStatus.taglines ? 'loaded' : 'fallback', status: systemStatus.taglines ? 'ok' : 'warn' }
      ];

      container.innerHTML = items.map(item =>
        `<div class="status-item"><span>${item.label}</span><span class="status-${item.status}">${item.value}</span></div>`
      ).join('');

      if (systemStatus.errors.length > 0) {
        container.innerHTML += `<div style="margin-top:8px;color:#ff5555;font-size:10px;">Errors: ${systemStatus.errors.length}</div>`;
        systemStatus.errors.slice(-3).forEach(err => {
          container.innerHTML += `<div style="color:#ff5555;font-size:9px;word-break:break-all;">${err}</div>`;
        });
      }
    }

    function toggleStatusReporter() {
      const reporter = document.getElementById('status-reporter');
      reporter.classList.toggle('visible');
      updateStatusReporter();
    }

    function reportError(context, error) {
      const msg = `[${context}] ${error.message || error}`;
      systemStatus.errors.push(msg);
      console.error(msg, error);
      updateStatusReporter();
    }

    // Test localStorage
    try {
      localStorage.setItem('_test', '1');
      localStorage.removeItem('_test');
      systemStatus.localStorage = true;
    } catch (e) {
      reportError('Storage', e);
    }

    // Test Clarity API availability
    systemStatus.clarityAPI = isElectron && !!window.electronAPI?.calculateClarity;

    // Status toggle button
    document.getElementById('status-toggle')?.addEventListener('click', toggleStatusReporter);
    document.getElementById('status-close')?.addEventListener('click', toggleStatusReporter);

    // Keyboard shortcut 'i' for inspect
    document.addEventListener('keydown', (e) => {
      if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        const active = document.activeElement;
        if (active?.tagName === 'INPUT' || active?.tagName === 'TEXTAREA' || active?.contentEditable === 'true') return;
        e.preventDefault();
        toggleStatusReporter();
      }
    });

  </script>

  <script>
    // Window controls (Electron)
    if (window.electronAPI) {
      document.getElementById('btn-minimize').addEventListener('click', () => window.electronAPI.minimize());
      document.getElementById('btn-maximize').addEventListener('click', () => window.electronAPI.maximize());
      document.getElementById('btn-close').addEventListener('click', () => window.electronAPI.close());
    }

    // Sidebar toggle
    (function() {
      const toggleBtn = document.getElementById('btn-toggle-sidebar');
      const app = document.getElementById('app');

      // Load saved state
      const isCollapsed = localStorage.getItem('objectiv-sidebar-collapsed') === 'true';
      if (isCollapsed) {
        app.classList.add('sidebar-collapsed');
      }

      toggleBtn.addEventListener('click', () => {
        app.classList.toggle('sidebar-collapsed');
        const collapsed = app.classList.contains('sidebar-collapsed');
        localStorage.setItem('objectiv-sidebar-collapsed', collapsed);
      });
    })();

    // Sidebar resize handle
    (function() {
      const handle = document.getElementById('resize-handle');
      const app = document.getElementById('app');
      let isResizing = false;

      // Load saved width
      const savedWidth = localStorage.getItem('objectiv-sidebar-width');
      if (savedWidth) {
        app.style.setProperty('--sidebar-width', savedWidth + 'px');
      }

      handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        handle.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = Math.min(500, Math.max(150, e.clientX));
        app.style.setProperty('--sidebar-width', newWidth + 'px');
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          handle.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          // Save width
          const width = getComputedStyle(app).getPropertyValue('--sidebar-width');
          localStorage.setItem('objectiv-sidebar-width', parseInt(width));
        }
      });
    })();

    // ========================================
    // PREVENT BROWSER ZOOM
    // ========================================
    document.addEventListener('wheel', (e) => {
      if (e.ctrlKey) e.preventDefault();
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '0')) {
        e.preventDefault();
      }
    });

    // ========================================
    // MOBILE RESPONSIVE NAVIGATION
    // ========================================
    const MOBILE_BREAKPOINT = 768;
    let isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

    // Initialize mobile view state
    function initMobileState() {
      isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
      const app = document.getElementById('app');

      if (isMobile) {
        app.classList.add('mobile-list-view');
        app.classList.remove('mobile-detail-view', 'sidebar-collapsed');
      } else {
        app.classList.remove('mobile-list-view', 'mobile-detail-view');
      }
    }

    // Switch between list/detail views on mobile
    function setMobileView(mode) {
      if (!isMobile) return;
      const app = document.getElementById('app');

      app.classList.add('transitioning');
      setTimeout(() => app.classList.remove('transitioning'), 250);

      if (mode === 'detail') {
        app.classList.remove('mobile-list-view');
        app.classList.add('mobile-detail-view');
      } else {
        app.classList.remove('mobile-detail-view');
        app.classList.add('mobile-list-view');
      }
    }

    // Smart resize handler
    window.addEventListener('resize', () => {
      const wasMobile = isMobile;
      isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

      if (isMobile && !wasMobile) {
        // Desktop → Mobile: show detail if objective selected, else list
        const app = document.getElementById('app');
        app.classList.remove('sidebar-collapsed');
        if (typeof data !== 'undefined' && data.objectives && data.objectives.length > 0 && typeof selectedObjectiveIndex !== 'undefined' && selectedObjectiveIndex >= 0) {
          setMobileView('detail');
        } else {
          setMobileView('list');
        }
      } else if (!isMobile && wasMobile) {
        // Mobile → Desktop: restore split-pane
        const app = document.getElementById('app');
        app.classList.remove('mobile-list-view', 'mobile-detail-view');
      }
    });

    // Back button handler
    document.getElementById('btn-mobile-back')?.addEventListener('click', () => setMobileView('list'));

    // Initialize mobile state on load
    initMobileState();
  </script>

  <script>
    // Data
    const STORAGE_KEY = 'objectiv-data';
    let data = loadData();

    // Storage initialization (non-blocking)
    // Runs after modules load, loads objectives and folders from Supabase
    async function initStorage() {
      if (!window.Objectiv?.Repository?.initializeData) {
        console.log('Repository module not loaded yet');
        return;
      }
      try {
        const loadedData = await window.Objectiv.Repository.initializeData();
        if (loadedData && loadedData.objectives) {
          console.log('Loaded', loadedData.objectives.length, 'objectives from Supabase');
          data.objectives = loadedData.objectives;
        }

        // Load folders
        if (window.Objectiv?.Repository?.loadAllFolders) {
          const folders = await window.Objectiv.Repository.loadAllFolders();
          console.log('Loaded', folders.length, 'folders from Supabase');
          data.folders = folders;
        }

        if (window.updateView) updateView();
        updateStatusReporter();

        // Subscribe to realtime changes for live updates (MCP, other clients)
        if (window.Objectiv?.Repository?.subscribeToChanges) {
          window.Objectiv.Repository.subscribeToChanges(async (payload) => {
            console.log('Realtime update received, refreshing...');
            const reloadedData = await window.Objectiv.Repository.reloadData();
            if (reloadedData && reloadedData.objectives) {
              data.objectives = reloadedData.objectives;
              if (window.updateView) updateView();
            }
          });
          console.log('Subscribed to realtime updates');
        }

        // Subscribe to folder changes
        if (window.Objectiv?.Repository?.subscribeToFolderChanges) {
          window.Objectiv.Repository.subscribeToFolderChanges(async (payload) => {
            console.log('Folder realtime update received, refreshing...');
            const folders = await window.Objectiv.Repository.loadAllFolders();
            data.folders = folders;
            if (window.updateView) updateView();
          });
          console.log('Subscribed to folder realtime updates');
        }
      } catch (e) {
        console.warn('Storage init failed:', e);
      }
    }
    // Run after a short delay to let modules load
    setTimeout(initStorage, 500);

    // Navigation state (simplified for split-pane)
    let selectedObjectiveIndex = 0;  // Which objective is selected in side list

    // View mode: 'objective'
    let viewMode = 'objective';

    // Hover preview state
    let hoverPreviewActive = false;
    let hoverPreviewItemData = null;

    // Prompt state
    let promptMode = null; // null, 'add', 'edit', 'refine', 'log', 'confirm'
    let promptStep = 0;
    let promptData = {};
    let promptTargetIndex = -1;
    let promptTargetSection = null;
    let skipBlurHandler = false; // Prevents stale blur handlers when switching edits

    // Scroll-based selection state (for buttery smooth scrolling)
    let _contentLoadTimeout = null;   // Debounce timer for content loading
    let _lastLoadedIndex = -1;        // Track last loaded item to avoid redundant loads
    const CONTENT_LOAD_DEBOUNCE = 150; // ms to wait after scroll stops

    // Next Step timer state
    let nextStepTimerInterval = null;

    // Load data (synchronous initial load - real data loaded async by initMarkdownStorage)
    function loadData() {
      // Return empty data initially - initMarkdownStorage will load from files
      return { objectives: [], folders: [] };
    }

    // Configuration: Set to true to enable dummy data (for testing only)
    const ENABLE_DUMMY_DATA = false;

    // Dummy data for development/demo (disabled by default)
    function getDummyData() {
      // Return empty data when disabled
      if (!ENABLE_DUMMY_DATA) {
        return { objectives: [] };
      }

      const now = new Date();
      const hourAgo = new Date(now - 60 * 60 * 1000);
      const twoHoursAgo = new Date(now - 2 * 60 * 60 * 1000);
      const dayAgo = new Date(now - 24 * 60 * 60 * 1000);
      const twoDaysAgo = new Date(now - 2 * 24 * 60 * 60 * 1000);
      const threeDaysAgo = new Date(now - 3 * 24 * 60 * 60 * 1000);
      const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

      return {
        objectives: [
          {
            id: 'obj1',
            name: 'Learn Rust programming',
            description: 'Master systems programming with Rust to build fast, reliable software and expand my technical skill set',
            clarityScore: 78,
            priorities: [
              { id: 'p1a', name: 'Complete the Rust Book', description: 'Work through all chapters systematically, doing every exercise', clarityScore: 85 },
              { id: 'p1b', name: 'Build a CLI tool', description: 'Create a practical file organizer or todo app to apply what I learn', clarityScore: 72 },
              { id: 'p1c', name: 'Practice on Exercism', description: 'Complete at least 20 exercises on the Rust track', clarityScore: 68 },
              { id: 'p1d', name: 'Contribute to open source', description: 'Find a beginner-friendly Rust project and submit my first PR', clarityScore: 45 }
            ],
            steps: [
              { id: 's1a', name: 'Installed rustup and cargo on my machine', loggedAt: weekAgo.toISOString(), orderNumber: 1 },
              { id: 's1b', name: 'Completed chapters 1-3 of the Rust Book', loggedAt: threeDaysAgo.toISOString(), orderNumber: 2 },
              { id: 's1c', name: 'Wrote ownership examples to understand move semantics', loggedAt: twoDaysAgo.toISOString(), orderNumber: 3 },
              { id: 's1d', name: 'Finished Chapter 4 - Ownership deep dive', loggedAt: dayAgo.toISOString(), orderNumber: 4 },
              { id: 's1e', name: 'Practiced borrowing with code examples', loggedAt: hourAgo.toISOString(), orderNumber: 5 }
            ]
          },
          {
            id: 'obj2',
            name: 'Build consistent fitness habits',
            description: 'Exercise regularly and improve nutrition to feel stronger and more energetic',
            clarityScore: 74,
            priorities: [
              { id: 'p2a', name: 'Exercise 4x per week', description: 'Upper/lower split with cardio on rest days', clarityScore: 85 },
              { id: 'p2b', name: 'Track nutrition consistently', description: 'Log meals in app, hit protein target of 150g daily', clarityScore: 70 },
              { id: 'p2c', name: 'Sleep 7-8 hours nightly', description: 'Consistent bedtime, no screens 1hr before sleep', clarityScore: 65 }
            ],
            steps: [
              { id: 's2a', name: 'Signed up for gym membership', loggedAt: weekAgo.toISOString(), orderNumber: 1 },
              { id: 's2b', name: 'Created workout split plan', loggedAt: threeDaysAgo.toISOString(), orderNumber: 2 },
              { id: 's2c', name: 'Upper body day - bench, rows, shoulders', loggedAt: twoDaysAgo.toISOString(), orderNumber: 3 },
              { id: 's2d', name: 'Meal prepped chicken and rice for the week', loggedAt: dayAgo.toISOString(), orderNumber: 4 },
              { id: 's2e', name: 'Leg day - squats, deadlifts, leg press', loggedAt: twoHoursAgo.toISOString(), orderNumber: 5 },
              { id: 's2f', name: 'Morning 2-mile run', loggedAt: now.toISOString(), orderNumber: 6 }
            ]
          },
          {
            id: 'obj3',
            name: 'Launch personal finance dashboard',
            description: 'Build a tool to aggregate and visualize spending across all my accounts',
            clarityScore: 52,
            priorities: [
              { id: 'p3a', name: 'Research Plaid API', description: 'Understand capabilities, pricing, and setup requirements', clarityScore: 65 },
              { id: 'p3b', name: 'Define MVP features', description: 'Account linking, transaction categorization, basic charts', clarityScore: 48 },
              { id: 'p3c', name: 'Choose tech stack', description: 'Rust backend with React frontend, or simpler approach?', clarityScore: 40 }
            ],
            steps: [
              { id: 's3a', name: 'Wrote down pain points with current finance tracking', loggedAt: threeDaysAgo.toISOString(), orderNumber: 1 },
              { id: 's3b', name: 'Reviewed Plaid documentation and pricing', loggedAt: dayAgo.toISOString(), orderNumber: 2 }
            ]
          },
          {
            id: 'obj4',
            name: 'Read 24 books this year',
            description: 'Read at least 2 books per month across technical, business, and personal development',
            clarityScore: 82,
            priorities: [
              { id: 'p4a', name: 'Read 30 minutes daily', description: 'Before bed, replace phone scrolling with reading', clarityScore: 90 },
              { id: 'p4b', name: 'Keep a reading log', description: 'Note key takeaways and how to apply them', clarityScore: 75 },
              { id: 'p4c', name: 'Mix genres deliberately', description: '1 technical, 1 non-fiction, 1 fiction per quarter', clarityScore: 70 }
            ],
            steps: [
              { id: 's4a', name: 'Finished "Atomic Habits" by James Clear', loggedAt: weekAgo.toISOString(), orderNumber: 1 },
              { id: 's4b', name: 'Started "Deep Work" by Cal Newport', loggedAt: threeDaysAgo.toISOString(), orderNumber: 2 },
              { id: 's4c', name: 'Completed chapter 3 of Deep Work', loggedAt: dayAgo.toISOString(), orderNumber: 3 },
              { id: 's4d', name: 'Added 5 books to reading list from recommendations', loggedAt: hourAgo.toISOString(), orderNumber: 4 }
            ]
          },
          {
            id: 'obj5',
            name: 'Improve productivity systems',
            description: 'Develop consistent workflows for capturing ideas, planning days, and reviewing progress',
            clarityScore: 68,
            priorities: [
              { id: 'p5a', name: 'Daily journaling habit', description: 'Morning pages or evening reflection, 10 minutes', clarityScore: 75 },
              { id: 'p5b', name: 'Weekly review ritual', description: 'Sunday afternoon review and plan for the week', clarityScore: 80 },
              { id: 'p5c', name: 'Reduce context switching', description: 'Time block calendar, batch similar tasks', clarityScore: 55 }
            ],
            steps: [
              { id: 's5a', name: 'Set up notes folder structure', loggedAt: weekAgo.toISOString(), orderNumber: 1 },
              { id: 's5b', name: 'Created weekly review template', loggedAt: threeDaysAgo.toISOString(), orderNumber: 2 },
              { id: 's5c', name: 'Completed first weekly review', loggedAt: twoDaysAgo.toISOString(), orderNumber: 3 },
              { id: 's5d', name: 'Tried pomodoro technique - worked well for focus', loggedAt: dayAgo.toISOString(), orderNumber: 4 }
            ]
          }
        ]
      };
    }

    // Migrate from old hierarchy
    function migrateData(oldData) {
      const newObjectives = [];
      for (const outcome of (oldData.outcomes || [])) {
        for (const objective of (outcome.objectives || [])) {
          // Collect all priorities and steps
          const allPriorities = [];
          const allSteps = [];

          for (const priority of (objective.priorities || [])) {
            allPriorities.push({
              id: priority.id,
              name: priority.name,
              description: priority.description || ''
            });
            for (const step of (priority.steps || [])) {
              allSteps.push({
                id: step.id,
                name: step.name,
                loggedAt: step.done ? new Date().toISOString() : new Date().toISOString()
              });
            }
          }

          newObjectives.push({
            id: objective.id,
            name: objective.name,
            description: objective.description || '',
            priorities: allPriorities,
            steps: allSteps
          });
        }
      }
      return { objectives: newObjectives };
    }

    // Save data to markdown files
    function saveData() {
      // Save to markdown files via Repository
      if (window.Objectiv?.Repository?.saveData) {
        window.Objectiv.Repository.saveData(data).catch(err => {
          console.error('Failed to save data:', err);
        });
      }
    }

    // Generate unique ID
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    }

    // Format timestamp for display
    // Shows: "Jan 9 2:34pm" (current year) or "Jan 9 2025 2:34pm" (other years)
    function formatTimestamp(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      const now = new Date();
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

      const month = months[date.getMonth()];
      const day = date.getDate();

      // Format time as 12-hour with am/pm
      let hours = date.getHours();
      const minutes = date.getMinutes();
      const ampm = hours >= 12 ? 'pm' : 'am';
      hours = hours % 12;
      if (hours === 0) hours = 12;
      const timeStr = minutes === 0
        ? `${hours}${ampm}`
        : `${hours}:${minutes.toString().padStart(2, '0')}${ampm}`;

      // Include year only if different from current year
      if (date.getFullYear() !== now.getFullYear()) {
        return `${month} ${day} ${date.getFullYear()} ${timeStr}`;
      }
      return `${month} ${day} ${timeStr}`;
    }

    // Calculate clarity level - uses cached LLM score or falls back to word count
    function calculateClarity(item) {
      // Use cached LLM score if available
      if (item.clarityScore !== undefined && item.clarityScore !== null) {
        const score = item.clarityScore;
        if (score <= 40) return 'fuzzy';
        if (score <= 60) return 'less fuzzy';
        if (score <= 80) return 'clear';
        return 'very clear';
      }

      // Fallback to word count
      const desc = item.description || '';
      const wordCount = desc.trim().split(/\s+/).filter(w => w).length;
      if (wordCount === 0) return 'fuzzy';
      if (wordCount < 5) return 'less fuzzy';
      if (wordCount < 15) return 'clear';
      return 'very clear';
    }

    // CLARITY_DISABLED: AI clarity badge scoring disabled - see "Archived code/clarity-badge-scoring.md"
    // Get clarity display HTML - now returns only edit button (clarity scoring disabled)
    function getClarityDisplay(item, section = 'objectives', index = 0) {
      // CLARITY_DISABLED: Original showed score + badge, now just edit button
      return `<span class="edit-btn" data-section="${section}" data-index="${index}">edit</span>`;
    }

    // ========================================
    // MODULAR LIST ITEM COMPONENT
    // Creates consistent list items with icon/content/meta columns
    // ========================================

    /**
     * Create a modular list item element
     * @param {Object} options
     * @param {string} options.icon - Icon/prefix content (number, dash, timestamp)
     * @param {string} options.iconClass - Additional classes for icon column
     * @param {string} options.content - Main text content
     * @param {boolean} options.contentEditable - Make content editable
     * @param {string} options.meta - Right column content (clarity badge, edit btn)
     * @param {boolean} options.selected - Is item selected
     * @param {Function} options.onClick - Click handler
     * @param {Object} options.dataAttrs - Data attributes for the item
     * @returns {HTMLElement}
     */
    function createListItem(options = {}) {
      const {
        icon = '',
        iconClass = '',
        content = '',
        contentEditable = false,
        meta = '',
        metaClass = '',
        selected = false,
        onClick = null,
        dataAttrs = {}
      } = options;

      const div = document.createElement('div');
      div.className = 'list-item' + (selected ? ' selected' : '');

      // Set data attributes
      for (const [key, value] of Object.entries(dataAttrs)) {
        div.dataset[key] = value;
      }

      // Build inner HTML with three columns
      let html = '';

      // Icon column (always present for alignment, can be empty)
      const iconClasses = ['list-item-icon', iconClass].filter(Boolean).join(' ');
      html += `<span class="${iconClasses}">${icon}</span>`;

      // Content column
      const contentAttrs = contentEditable ? ' contenteditable="true" spellcheck="false"' : '';
      const escapedContent = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      html += `<span class="list-item-content"${contentAttrs}>${escapedContent}</span>`;

      // Meta column (optional)
      if (meta) {
        const metaClasses = ['list-item-meta', metaClass].filter(Boolean).join(' ');
        html += `<span class="${metaClasses}">${meta}</span>`;
      }

      div.innerHTML = html;

      // Attach click handler
      if (onClick) {
        div.onclick = onClick;
      }

      return div;
    }

    /**
     * CLARITY_DISABLED: Get clarity meta HTML for list items
     * Now returns only edit button (clarity scoring disabled)
     * See "Archived code/clarity-badge-scoring.md" for original implementation
     */
    function getClarityMeta(item, section = 'objectives', index = 0) {
      // CLARITY_DISABLED: Original showed score + badge, now just edit button
      return `<span class="edit-btn" data-section="${section}" data-index="${index}">edit</span>`;
    }

    // CLARITY_DISABLED: Pending clarity requests (disabled - no API calls)
    let clarityQueue = [];
    let clarityProcessing = false;

    // CLARITY_DISABLED: LLM clarity calculation disabled
    // See "Archived code/clarity-badge-scoring.md" for original implementation
    function refreshClarity(item) {
      // CLARITY_DISABLED: Feature disabled, return early to skip API calls
      return;
    }

    async function processClarityQueue() {
      // Skip clarity processing in browser mode (no Electron API)
      if (!window.electronAPI?.calculateClarity) {
        clarityQueue.forEach(item => {
          item._clarityQueued = false;
          item._clarityLoading = false;
        });
        clarityQueue = [];
        clarityProcessing = false;
        return;
      }

      while (clarityQueue.length > 0) {
        const item = clarityQueue.shift();
        item._clarityQueued = false;

        const cacheKey = `${item.name}|${item.description || ''}`;
        if (item._clarityKey === cacheKey && item.clarityScore !== undefined) {
          continue; // Already done
        }

        try {
          item._clarityLoading = true;
          console.log('Requesting clarity for:', item.name);

          const result = await window.electronAPI.calculateClarity(item.name, item.description || '');
          item._clarityLoading = false;

          if (result.error) {
            console.log('Clarity error:', result.error);
          } else if (result.score !== null) {
            console.log('Clarity score:', result.score + '%');
            item.clarityScore = result.score;
            item._clarityKey = cacheKey;
            saveData();
          }
        } catch (err) {
          item._clarityLoading = false;
          reportError('Clarity', err);
        }
      }

      clarityProcessing = false;
      // Only update content view (not side list) when clarity scores arrive
      if (!promptMode) {
        renderContentView();
      }
    }

    // CLARITY_DISABLED: Refresh clarity for all items (disabled)
    // See "Archived code/clarity-badge-scoring.md" for original implementation
    async function refreshAllClarity() {
      // CLARITY_DISABLED: Feature disabled, return early
      return;
    }

    // Capitalize first letter
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    // Embedded taglines fallback (works without network/CORS)
    const FALLBACK_TAGLINES = [
      'Proceed.',
      'Begin where you are.',
      'One step at a time.',
      'Clarity through action.',
      'Define. Refine. Execute.'
    ];

    // Show intro animation (skippable with click or spacebar)
    async function showIntro() {
      let tagline = FALLBACK_TAGLINES[Math.floor(Math.random() * FALLBACK_TAGLINES.length)];
      try {
        const response = await fetch('taglines.json');
        if (response.ok) {
          const taglines = await response.json();
          tagline = taglines[Math.floor(Math.random() * taglines.length)];
          systemStatus.taglines = true;
        }
      } catch (e) {
        // Silently use fallback - common in file:// mode
        console.log('Using fallback taglines (fetch unavailable)');
      }

      const introText = document.getElementById('intro-text');
      const introTagline = document.getElementById('intro-tagline');
      const introCursor = document.getElementById('intro-cursor');
      const introEl = document.getElementById('intro');
      const appEl = document.getElementById('app');

      let skipped = false;

      // Skip handler
      const skip = () => {
        if (skipped) return;
        skipped = true;
        document.removeEventListener('click', skip);
        document.removeEventListener('keydown', handleKey);
        introEl.style.display = 'none';
        appEl.style.display = 'grid';
      };

      const handleKey = (e) => {
        if (e.code === 'Space' || e.key === ' ') {
          e.preventDefault();
          skip();
        }
      };

      // Listen for skip inputs
      document.addEventListener('click', skip);
      document.addEventListener('keydown', handleKey);

      await typeText(introText, 'Objectiv', 80, null, () => skipped);
      if (skipped) return;
      await new Promise(r => setTimeout(r, 300));
      if (skipped) return;
      introTagline.style.opacity = '1';
      introTagline.appendChild(introCursor);
      await typeText(introTagline, tagline, 80, introCursor, () => skipped);
      if (skipped) return;
      await new Promise(r => setTimeout(r, 1500));
      if (skipped) return;

      // Clean up and show app
      document.removeEventListener('click', skip);
      document.removeEventListener('keydown', handleKey);
      introEl.style.display = 'none';
      appEl.style.display = 'grid';
    }

    function typeText(element, text, speed, cursorEl = null, isSkipped = () => false) {
      return new Promise((resolve) => {
        let i = 0;
        const interval = setInterval(() => {
          if (isSkipped()) {
            clearInterval(interval);
            resolve();
            return;
          }
          if (i <= text.length) {
            if (cursorEl) {
              element.textContent = text.slice(0, i);
              element.appendChild(cursorEl);
            } else {
              element.textContent = text.slice(0, i);
            }
            i++;
          } else {
            clearInterval(interval);
            resolve();
          }
        }, speed);
      });
    }

    // Create confirm row HTML
    function createConfirmRow(text) {
      return `
        <div class="confirm-row">
          <div class="confirm-text">${text}</div>
          <div class="confirm-hint">[y] Yes  [n] No  [Esc] Cancel</div>
        </div>
      `;
    }

    // ========================================
    // SPLIT-PANE RENDERING
    // ========================================

    // Render the unified side list (objectives + folder explorer)
    async function renderSideList() {
      const container = document.getElementById('side-list-items');

      // Reset content load tracking when list is rebuilt (indices may change)
      _lastLoadedIndex = -1;

      const SideListState = window.Objectiv?.SideListState;
      if (!SideListState) {
        // Module not ready, fall back to basic render
        container.innerHTML = '';
        renderSideListBasic(container);
        return;
      }

      // Build the unified list of navigable items
      const isAddingObjective = promptMode === 'add' && promptTargetSection === 'objectives';
      SideListState.rebuildItems({
        objectives: data.objectives,
        folders: data.folders || [],
        isAddingObjective
      });

      const items = SideListState.getItems();
      const selectedIdx = SideListState.getSelectedIndex();

      // Build all items in a fragment first (no DOM until complete)
      const fragment = document.createDocumentFragment();
      items.forEach((itemData, idx) => {
        // No selection state on mobile - just tap to navigate
        const isSelected = !isMobile && idx === selectedIdx;
        const element = createSideListItem(itemData, idx, isSelected);
        fragment.appendChild(element);
      });

      // Swap content in one operation (prevents empty state flicker)
      container.innerHTML = '';
      container.appendChild(fragment);

      // Add insertion indicator element for drag positioning
      let insertIndicator = container.querySelector('.drag-insert-indicator');
      if (!insertIndicator) {
        insertIndicator = document.createElement('div');
        insertIndicator.className = 'drag-insert-indicator';
        container.style.position = 'relative';
        container.appendChild(insertIndicator);
      }

      // Initialize Lucide icons
      if (window.lucide) {
        lucide.createIcons();
      }

      // Scroll selected to snap position
      const selectedEl = container.querySelector('.side-item.selected');
      if (selectedEl) {
        selectedEl.scrollIntoView({ block: 'start' });
      }
    }

    // Create a side list item element based on type
    function createSideListItem(itemData, idx, isSelected) {
      const SideListState = window.Objectiv?.SideListState;
      const ItemType = SideListState?.ItemType || {};

      const item = document.createElement('div');
      item.className = 'side-item' + (isSelected ? ' selected' : '');
      item.dataset.idx = idx;

      // Set depth for indentation
      if (itemData.depth !== undefined) {
        item.dataset.depth = itemData.depth;
      }

      // Selection indicator (always rendered, CSS controls visibility via .selected)
      const indicator = '<span class="side-item-indicator">●</span>';

      switch (itemData.type) {
        case ItemType.UNFILED_HEADER:
          item.className = 'side-item unfiled-header';
          item.innerHTML = `<span class="side-item-name">Unfiled</span>`;
          // Make unfiled area a drop target
          item.dataset.dropTarget = 'unfiled';
          setupDropTarget(item, 'unfiled', null);
          break;

        case ItemType.FOLDER:
          const isExpanded = SideListState.isFolderExpanded(itemData.folderId);
          item.className = 'side-item folder-row' + (isSelected ? ' selected' : '');
          item.dataset.type = 'folder';
          item.dataset.folderId = itemData.folderId;

          const folderIcon = isExpanded
            ? '<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5Z"/><path d="M3 10h18"/></svg>'
            : '<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5Z"/></svg>';

          item.innerHTML = `
            ${folderIcon}<span class="folder-name">${itemData.name || 'Unnamed Folder'}</span>${indicator}
          `;

          // Click to expand/collapse
          item.onclick = (e) => {
            e.stopPropagation();
            SideListState.toggleFolder(itemData.folderId);
            renderSideList();
          };

          // Right-click context menu for delete
          item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showFolderContextMenu(e, itemData);
          });

          // Make folder draggable and a drop target
          setupDraggable(item, 'folder', itemData.folderId, itemData.data);
          setupDropTarget(item, 'folder', itemData.folderId);
          break;

        case ItemType.OBJECTIVE:
          const isEditing = promptMode === 'add' && promptTargetSection === 'objectives' && promptTargetIndex === itemData.index;
          item.dataset.type = 'objective';
          item.dataset.objIndex = itemData.index;
          item.dataset.objectiveId = itemData.objectiveId;
          item.dataset.folderId = itemData.folderId || '';

          if (isEditing) {
            item.innerHTML = `
              <span class="side-item-name" contenteditable="true" spellcheck="true" data-placeholder="Name your objective"></span>
            `;
            item.style.color = '#0891b2';
          } else {
            item.innerHTML = `
              <span class="side-item-name">${itemData.name}</span>${indicator}
            `;
            item.onclick = () => handleSideItemClick(idx, itemData);

            // Right-click context menu for delete
            item.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              showObjectiveContextMenu(e, itemData);
            });
          }

          // Make objectives draggable and drop targets (for position-aware reordering)
          setupDraggable(item, 'objective', itemData.objectiveId, itemData.data);
          setupDropTarget(item, 'objective', itemData.objectiveId);
          break;

        case ItemType.ADD_FOLDER:
          item.className = 'side-item add-option add-folder' + (isSelected ? ' selected' : '');
          item.dataset.type = 'add-folder';
          item.innerHTML = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 10v6m-3-3h6"/><path d="M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5Z"/></svg><span class="side-item-name">Add folder</span>${indicator}`;
          item.onclick = () => startAddFolder();
          break;

        case ItemType.ADD_OBJECTIVE:
          item.className = 'side-item add-option' + (isSelected ? ' selected' : '');
          item.dataset.type = 'add-objective';
          item.innerHTML = `<span class="side-item-name">+ Add objective</span>${indicator}`;
          item.onclick = () => handleSideItemClick(idx, itemData);
          break;

        default:
          item.innerHTML = `<span class="side-item-name">${itemData.name || '?'}</span>`;
      }

      return item;
    }

    // Show context menu for objectives (right-click)
    function showObjectiveContextMenu(e, itemData) {
      const ContextMenu = window.Objectiv?.ContextMenu;
      const DeleteModal = window.Objectiv?.DeleteModal;

      if (!ContextMenu) {
        console.warn('ContextMenu module not loaded');
        return;
      }

      ContextMenu.showContextMenu({
        x: e.clientX,
        y: e.clientY,
        items: [
          {
            label: 'Delete',
            danger: true,
            action: () => {
              if (!DeleteModal) {
                console.warn('DeleteModal module not loaded');
                return;
              }

              DeleteModal.showDeleteModal({
                itemName: itemData.name || 'Unnamed Objective',
                itemType: 'objective',
                onConfirm: async () => {
                  try {
                    // Find the objective in data
                    const objective = data.objectives.find(o => o.id === itemData.objectiveId);
                    if (!objective) {
                      console.error('Objective not found:', itemData.objectiveId);
                      return;
                    }

                    // Delete from storage
                    if (window.Objectiv?.Repository?.deleteOneObjective) {
                      await window.Objectiv.Repository.deleteOneObjective(objective);
                    }

                    // Remove from local data
                    data.objectives = data.objectives.filter(o => o.id !== itemData.objectiveId);

                    // Adjust selection if needed
                    if (selectedObjectiveIndex >= data.objectives.length) {
                      selectedObjectiveIndex = Math.max(0, data.objectives.length - 1);
                    }

                    // Refresh the view
                    updateView();
                    showToast('Objective deleted');
                  } catch (err) {
                    console.error('Failed to delete objective:', err);
                    showToast('Failed to delete objective');
                  }
                }
              });
            }
          }
        ]
      });
    }

    // Show context menu for folders (right-click)
    function showFolderContextMenu(e, itemData) {
      const ContextMenu = window.Objectiv?.ContextMenu;
      const DeleteModal = window.Objectiv?.DeleteModal;

      if (!ContextMenu) {
        console.warn('ContextMenu module not loaded');
        return;
      }

      ContextMenu.showContextMenu({
        x: e.clientX,
        y: e.clientY,
        items: [
          {
            label: 'Delete',
            danger: true,
            action: () => {
              if (!DeleteModal) {
                console.warn('DeleteModal module not loaded');
                return;
              }

              DeleteModal.showDeleteModal({
                itemName: itemData.name || 'Unnamed Folder',
                itemType: 'folder',
                onConfirm: async () => {
                  try {
                    // Delete from storage
                    if (window.Objectiv?.Repository?.deleteFolder) {
                      await window.Objectiv.Repository.deleteFolder(itemData.folderId);
                    }

                    // Remove from local data
                    data.folders = data.folders.filter(f => f.id !== itemData.folderId);

                    // Move any objectives in this folder to unfiled
                    data.objectives.forEach(obj => {
                      if (obj.folderId === itemData.folderId) {
                        obj.folderId = null;
                      }
                    });

                    // Refresh the view
                    updateView();
                    showToast('Folder deleted');
                  } catch (err) {
                    console.error('Failed to delete folder:', err);
                    showToast('Failed to delete folder');
                  }
                }
              });
            }
          }
        ]
      });
    }

    // Track current drag insert position (must be declared before setupDraggable)
    let _dragInsertPosition = null;

    // Hide the insertion indicator line (must be declared before setupDraggable)
    function hideInsertionIndicator() {
      const container = document.getElementById('side-list-items');
      const indicator = container?.querySelector('.drag-insert-indicator');
      if (indicator) {
        indicator.classList.remove('visible');
      }
    }

    // Setup drag and drop handlers
    function setupDraggable(element, type, id, itemData) {
      element.draggable = true;

      element.addEventListener('dragstart', (e) => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('application/json', JSON.stringify({ type, id }));
        element.classList.add('dragging');
        window._draggedItem = { type, id, data: itemData };
      });

      element.addEventListener('dragend', (e) => {
        element.classList.remove('dragging');
        window._draggedItem = null;
        _dragInsertPosition = null;
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        document.querySelectorAll('.drag-over-folder').forEach(el => el.classList.remove('drag-over-folder'));
        hideInsertionIndicator();
      });
    }

    function setupDropTarget(element, targetType, targetId) {
      element.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (!window._draggedItem) return;

        const { type: dragType, id: dragId } = window._draggedItem;

        // Validate drop - can't drop on self
        if (dragType === 'folder' && targetType === 'folder' && dragId === targetId) {
          e.dataTransfer.dropEffect = 'none';
          return;
        }
        if (dragType === 'objective' && targetType === 'objective' && dragId === targetId) {
          e.dataTransfer.dropEffect = 'none';
          hideInsertionIndicator();
          return;
        }

        e.dataTransfer.dropEffect = 'move';

        // For objectives, calculate insert position (before/after)
        if (targetType === 'objective' && dragType === 'objective') {
          const rect = element.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          const position = e.clientY < midY ? 'before' : 'after';

          // Get target's folder context
          const targetFolderId = element.dataset.folderId || null;

          _dragInsertPosition = {
            targetId,
            targetType,
            position,
            folderId: targetFolderId
          };

          showInsertionIndicator(element, position);
          element.classList.remove('drag-over');
        } else if (targetType === 'folder') {
          // Dropping into a folder
          element.classList.add('drag-over-folder');
          hideInsertionIndicator();
          _dragInsertPosition = {
            targetId,
            targetType: 'folder',
            position: 'into',
            folderId: targetId
          };
        } else {
          element.classList.add('drag-over');
          hideInsertionIndicator();
          _dragInsertPosition = {
            targetId,
            targetType,
            position: 'into',
            folderId: null
          };
        }
      });

      element.addEventListener('dragleave', (e) => {
        element.classList.remove('drag-over');
        element.classList.remove('drag-over-folder');
        // Don't hide indicator on leave - it may be transitioning between elements
      });

      element.addEventListener('drop', async (e) => {
        e.preventDefault();
        element.classList.remove('drag-over');
        element.classList.remove('drag-over-folder');
        hideInsertionIndicator();

        if (!window._draggedItem) return;

        const { type: dragType, id: dragId, data: dragData } = window._draggedItem;
        const insertPosition = _dragInsertPosition;
        window._draggedItem = null;
        _dragInsertPosition = null;

        try {
          if (dragType === 'objective') {
            await handleObjectiveDrop(dragId, dragData, insertPosition);
          } else if (dragType === 'folder') {
            const newParentId = targetType === 'unfiled' ? null : targetId;
            if (window.Objectiv?.Repository?.updateFolder) {
              await window.Objectiv.Repository.updateFolder({ id: dragId, parentId: newParentId });
              // Reload folders
              const folders = await window.Objectiv.Repository.loadAllFolders();
              data.folders = folders;
              renderSideList();
              console.log('Moved folder', dragId, 'to parent', newParentId || 'root');
            }
          }
        } catch (err) {
          console.error('Drop failed:', err);
        }
      });
    }

    // Show the insertion indicator line
    function showInsertionIndicator(element, position) {
      const container = document.getElementById('side-list-items');
      const indicator = container.querySelector('.drag-insert-indicator');
      if (!indicator) return;

      const containerRect = container.getBoundingClientRect();
      const elementRect = element.getBoundingClientRect();

      // Position the indicator at the top or bottom of the element
      const y = position === 'before'
        ? elementRect.top - containerRect.top - 1
        : elementRect.bottom - containerRect.top - 1;

      indicator.style.top = `${y}px`;
      indicator.classList.add('visible');
    }

    // Handle objective drop with position awareness
    async function handleObjectiveDrop(dragId, dragData, insertPosition) {
      if (!insertPosition) {
        console.warn('No insert position for objective drop');
        return;
      }

      const Repository = window.Objectiv?.Repository;
      if (!Repository?.updateObjectiveOrder) {
        console.warn('Repository.updateObjectiveOrder not available');
        return;
      }

      const { targetId, targetType, position, folderId } = insertPosition;

      // Determine the new folder (null for unfiled)
      const newFolderId = targetType === 'unfiled' ? null :
                          targetType === 'folder' ? targetId : folderId;

      // Calculate the new order index
      let newOrderIndex;

      if (targetType === 'objective' && (position === 'before' || position === 'after')) {
        // Dropping relative to another objective
        newOrderIndex = calculateOrderIndex(targetId, position, newFolderId, data.objectives);
      } else if (targetType === 'folder') {
        // Dropping into a folder - append at end
        newOrderIndex = calculateOrderIndexForFolderEnd(targetId, data.objectives);
      } else {
        // Dropping into unfiled - append at end
        newOrderIndex = calculateOrderIndexForUnfiledEnd(data.objectives);
      }

      // Update the objective's order and folder
      await Repository.updateObjectiveOrder(dragId, newOrderIndex, newFolderId);

      // Reload and refresh
      const reloadedData = await Repository.reloadData();
      if (reloadedData) data.objectives = reloadedData.objectives;
      renderSideList();

      console.log('Reordered objective', dragId, 'to index', newOrderIndex, 'in folder', newFolderId || 'unfiled');
    }

    // Calculate order index for inserting before/after a target objective
    function calculateOrderIndex(targetId, position, folderId, objectives) {
      // Get objectives in the same context (folder), sorted by orderIndex
      const contextObjs = objectives
        .filter(o => (o.folderId || null) === folderId)
        .sort((a, b) => (a.orderIndex || 0) - (b.orderIndex || 0));

      const targetIdx = contextObjs.findIndex(o => o.id === targetId);
      if (targetIdx === -1) {
        // Target not found, append at end with large gap
        return (contextObjs.length + 1) * 1000;
      }

      const target = contextObjs[targetIdx];
      const targetOrder = target.orderIndex || 0;

      if (position === 'before') {
        if (targetIdx === 0) {
          // Insert before first item - use half of its order
          return Math.floor(targetOrder / 2);
        } else {
          // Insert between previous and target
          const prev = contextObjs[targetIdx - 1];
          const prevOrder = prev.orderIndex || 0;
          return Math.floor((prevOrder + targetOrder) / 2);
        }
      } else {
        // position === 'after'
        if (targetIdx === contextObjs.length - 1) {
          // Insert after last item - add 1000
          return targetOrder + 1000;
        } else {
          // Insert between target and next
          const next = contextObjs[targetIdx + 1];
          const nextOrder = next.orderIndex || 0;
          return Math.floor((targetOrder + nextOrder) / 2);
        }
      }
    }

    // Calculate order index for appending to end of a folder
    function calculateOrderIndexForFolderEnd(folderId, objectives) {
      const folderObjs = objectives
        .filter(o => o.folderId === folderId)
        .sort((a, b) => (a.orderIndex || 0) - (b.orderIndex || 0));

      if (folderObjs.length === 0) {
        return 1000;
      }

      const lastObj = folderObjs[folderObjs.length - 1];
      return (lastObj.orderIndex || 0) + 1000;
    }

    // Calculate order index for appending to end of unfiled
    function calculateOrderIndexForUnfiledEnd(objectives) {
      const unfiledObjs = objectives
        .filter(o => !o.folderId)
        .sort((a, b) => (a.orderIndex || 0) - (b.orderIndex || 0));

      if (unfiledObjs.length === 0) {
        return 1000;
      }

      const lastObj = unfiledObjs[unfiledObjs.length - 1];
      return (lastObj.orderIndex || 0) + 1000;
    }

    // Handle click on side list item
    async function handleSideItemClick(idx, itemData) {
      const SideListState = window.Objectiv?.SideListState;
      const ItemType = SideListState?.ItemType || {};

      // Clear hover preview on click (we're now selecting)
      hoverPreviewActive = false;
      hoverPreviewItemData = null;

      // Cancel any pending scroll-based content load - click takes priority
      if (_contentLoadTimeout) {
        clearTimeout(_contentLoadTimeout);
        _contentLoadTimeout = null;
      }
      // Reset last loaded so this click's content will load
      _lastLoadedIndex = -1;

      // Update selection
      SideListState.setSelectedIndex(idx);
      playNotch();

      // Action to run after scroll completes
      async function executeAction() {
        switch (itemData.type) {
          case ItemType.OBJECTIVE:
            commitEditInPlace();
            selectedObjectiveIndex = itemData.index;
            viewMode = 'objective';
            renderContentView();
            updateSideListSelection();
            // Navigate to detail view on mobile
            if (isMobile) setMobileView('detail');
            break;

          case ItemType.ADD_OBJECTIVE:
            startAddObjective();
            break;
        }
      }

      // Mobile: execute immediately, no scroll animation needed
      if (isMobile) {
        executeAction();
        return;
      }

      // Desktop: Scroll clicked item to the 30vh snap line (smooth animation)
      const container = document.getElementById('side-list-items');
      const items = container?.querySelectorAll('.side-item');
      if (container && items && items[idx]) {
        const snapOffset = window.innerHeight * 0.30;
        const targetScroll = idx === 0 ? 0 : items[idx].offsetTop - snapOffset + container.offsetTop;
        const startScroll = container.scrollTop;
        const distance = targetScroll - startScroll;
        const duration = 200; // ms - smooth
        const startTime = performance.now();

        function animateScroll(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          // Ease-out cubic for smooth deceleration
          const eased = 1 - Math.pow(1 - progress, 3);
          container.scrollTop = startScroll + distance * eased;
          if (progress < 1) {
            requestAnimationFrame(animateScroll);
          } else {
            executeAction(); // Run action after animation completes
          }
        }
        requestAnimationFrame(animateScroll);
      } else {
        // No scroll needed, run action immediately
        executeAction();
      }
    }

    // Update visual selection without full re-render
    // Desktop only - mobile has no selection state
    function updateSideListSelection() {
      if (isMobile) return;

      const SideListState = window.Objectiv?.SideListState;
      if (!SideListState) return;

      const selectedIdx = SideListState.getSelectedIndex();
      const items = document.querySelectorAll('#side-list-items .side-item[data-idx]');

      items.forEach((item) => {
        const idx = parseInt(item.dataset.idx, 10);
        if (idx === selectedIdx) {
          item.classList.add('selected');
          item.scrollIntoView({ block: 'start' });
        } else {
          item.classList.remove('selected');
        }
      });
    }


    // Basic fallback render (when modules not ready)
    function renderSideListBasic(container) {
      data.objectives.forEach((obj, index) => {
        const item = document.createElement('div');
        // No selection state on mobile
        item.className = 'side-item' + (!isMobile && index === selectedObjectiveIndex ? ' selected' : '');
        item.innerHTML = `
          <span class="side-item-name">${obj.name}</span>
          <span class="side-item-indicator">●</span>
        `;
        item.onclick = () => {
          selectedObjectiveIndex = index;
          updateView();
        };
        container.appendChild(item);
      });
    }

    // Legacy: renderFolderExplorer is now integrated into renderSideList
    function renderFolderExplorer() {
      // No longer needed - folder explorer is part of unified side list
    }

    // Select objective by index (uses unified navigation state)
    function selectObjective(index) {
      // Commit any current edit before switching objectives
      commitEditInPlace();

      // Auto-pause next step timer before switching
      autoPauseNextStepTimer();

      if (index === selectedObjectiveIndex) return;

      // Update unified state to select this objective
      const SideListState = window.Objectiv?.SideListState;
      if (SideListState) {
        SideListState.selectItem(SideListState.ItemType.OBJECTIVE, index);
      }

      selectedObjectiveIndex = index;
      viewMode = 'objective';
      updateSideListSelection();
      renderContentView();
    }

    // Render the content view (selected objective's details)
    function renderContentView() {
      renderObjectiveView();
    }

    // Preview content on hover (shows content without changing selection)
    async function startHoverPreview(itemData) {
      const SideListState = window.Objectiv?.SideListState;
      const ItemType = SideListState?.ItemType || {};

      // Only preview objectives
      if (itemData.type !== ItemType.OBJECTIVE) {
        return;
      }

      hoverPreviewActive = true;
      hoverPreviewItemData = itemData;

      // Preview objective content
      const obj = data.objectives[itemData.index];
      if (!obj) return;

      const headerTitle = document.getElementById('content-header-title');
      const headerDesc = document.getElementById('content-header-description');
      const body = document.getElementById('content-body');

      headerTitle.textContent = obj.name;
      headerDesc.textContent = obj.description || '';

      body.innerHTML = '';
      renderContentPriorities(body, obj);
      renderContentNextStep(body, obj);
      renderContentSteps(body, obj);
    }

    // End hover preview (restore selected content)
    function endHoverPreview() {
      if (!hoverPreviewActive) return;

      hoverPreviewActive = false;
      hoverPreviewItemData = null;

      // Re-render the actually selected content
      renderContentView();
    }

    // Render objective view
    function renderObjectiveView() {
      const headerTitle = document.getElementById('content-header-title');
      const headerDesc = document.getElementById('content-header-description');
      const body = document.getElementById('content-body');

      if (data.objectives.length === 0) {
        headerTitle.textContent = 'No objectives yet';
        headerDesc.textContent = 'Add your first objective to get started';
        body.innerHTML = '';
        return;
      }

      // Clamp index to valid range
      if (selectedObjectiveIndex < 0) {
        selectedObjectiveIndex = 0;
      }
      if (selectedObjectiveIndex >= data.objectives.length) {
        selectedObjectiveIndex = data.objectives.length - 1;
      }

      const obj = data.objectives[selectedObjectiveIndex];
      headerTitle.textContent = obj.name;
      headerDesc.textContent = obj.description || '';

      // Render priorities, next step, and steps
      body.innerHTML = '';
      renderContentPriorities(body, obj);
      renderContentNextStep(body, obj);
      renderContentSteps(body, obj);

      // Refresh clarity scores
      refreshClarity(obj);
      obj.priorities.forEach(p => refreshClarity(p));
    }

    // Render priorities section in content view
    function renderContentPriorities(container, obj) {
      const header = document.createElement('div');
      header.className = 'section-header';
      header.textContent = 'PRIORITIES';
      container.appendChild(header);

      obj.priorities.forEach((priority, index) => {
        // Handle confirm mode
        if (promptMode === 'confirm' && promptTargetSection === 'priorities' && promptTargetIndex === index) {
          const div = document.createElement('div');
          div.innerHTML = createConfirmRow(`Delete "${priority.name}"?`);
          container.appendChild(div.firstElementChild);
          return;
        }

        const isAdding = promptMode === 'add' && promptTargetSection === 'priorities' && promptTargetIndex === index;
        const isEditing = promptMode === 'edit' && promptTargetSection === 'priorities' && promptTargetIndex === index;
        const isRefining = promptMode === 'refine' && promptTargetSection === 'priorities' && promptTargetIndex === index;
        const isInEditMode = isAdding || isEditing || isRefining;

        let textContent = priority.name;
        if (isRefining) textContent = priority.description || '';

        // CLARITY_DISABLED: Clarity display removed for priorities
        // See "Archived code/clarity-badge-scoring.md" for original implementation

        const listItem = createListItem({
          icon: '',
          iconClass: '',
          content: textContent,
          contentEditable: isInEditMode,
          meta: '', // CLARITY_DISABLED: was clarityMeta with score + badge
          selected: false
        });

        // Add data attributes for edit controller
        listItem.dataset.section = 'priorities';
        listItem.dataset.index = index;

        // Add placeholder for new items
        if (isAdding) {
          const contentEl = listItem.querySelector('.list-item-content');
          if (contentEl) {
            contentEl.dataset.placeholder = 'Name your priority';
          }
        }

        container.appendChild(listItem);
      });

      // Add priority button at bottom (only show if not currently adding and under limit)
      if (!(promptMode === 'add' && promptTargetSection === 'priorities') && obj.priorities.length < 3) {
        const addDiv = document.createElement('div');
        addDiv.className = 'add-option';
        addDiv.innerHTML = '+ Add priority';
        addDiv.onclick = () => startAddPriority();
        container.appendChild(addDiv);
      }
    }

    // ========================================
    // Next Step Section
    // ========================================

    // Format seconds to H:MM:SS display
    function formatTimerDisplay(totalSeconds) {
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    // Format duration for step display (e.g., "15m" or "1h 5m")
    function formatDuration(totalSeconds) {
      if (totalSeconds < 60) return '<1m';
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      if (hours > 0) {
        return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
      }
      return `${minutes}m`;
    }

    // Start the next step timer
    function startNextStepTimer() {
      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj) return;

      // Initialize nextStep if needed
      if (!obj.nextStep) {
        obj.nextStep = { text: '', elapsedSeconds: 0, isRunning: false };
      }

      obj.nextStep.isRunning = true;

      // Clear any existing interval
      if (nextStepTimerInterval) {
        clearInterval(nextStepTimerInterval);
      }

      // Update timer every second
      nextStepTimerInterval = setInterval(() => {
        if (obj.nextStep && obj.nextStep.isRunning) {
          obj.nextStep.elapsedSeconds++;
          updateNextStepTimerDisplay(obj);
        }
      }, 1000);

      // Update UI immediately
      updateNextStepTimerDisplay(obj);
      updateNextStepPlayButton(obj);
    }

    // Pause the next step timer
    function pauseNextStepTimer() {
      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj || !obj.nextStep) return;

      obj.nextStep.isRunning = false;

      if (nextStepTimerInterval) {
        clearInterval(nextStepTimerInterval);
        nextStepTimerInterval = null;
      }

      // Update UI
      updateNextStepTimerDisplay(obj);
      updateNextStepPlayButton(obj);

      // Save to file
      saveData();
    }

    // Update timer display without re-rendering
    function updateNextStepTimerDisplay(obj) {
      const timerEl = document.querySelector('.next-step-timer');
      if (timerEl && obj.nextStep) {
        timerEl.textContent = formatTimerDisplay(obj.nextStep.elapsedSeconds);
        timerEl.classList.toggle('running', obj.nextStep.isRunning);
      }
    }

    // Update play/pause button without re-rendering (CSS handles icon via .running class)
    function updateNextStepPlayButton(obj) {
      const btn = document.querySelector('.next-step-play-btn');
      if (btn && obj.nextStep) {
        btn.classList.toggle('running', obj.nextStep.isRunning);
      }
    }

    // Toggle timer play/pause
    function toggleNextStepTimer() {
      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj) return;

      if (obj.nextStep?.isRunning) {
        pauseNextStepTimer();
      } else {
        startNextStepTimer();
      }
    }

    // Complete next step - move to steps list
    function completeNextStep() {
      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj || !obj.nextStep || !obj.nextStep.text.trim()) return;

      // Pause timer first
      if (obj.nextStep.isRunning) {
        pauseNextStepTimer();
      }

      // Create new step from next step
      const newStep = {
        id: Date.now().toString(36) + Math.random().toString(36).substr(2, 9),
        name: obj.nextStep.text.trim(),
        loggedAt: new Date().toISOString(),
        orderNumber: (obj.steps?.length || 0) + 1,
        duration: obj.nextStep.elapsedSeconds // Store duration in seconds
      };

      // Add to steps
      if (!obj.steps) obj.steps = [];
      obj.steps.push(newStep);

      // Clear next step
      obj.nextStep = { text: '', elapsedSeconds: 0, isRunning: false };

      // Save and re-render
      saveData();
      renderContentView();
    }

    // Save next step text on input
    function saveNextStepText(text) {
      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj) return;

      if (!obj.nextStep) {
        obj.nextStep = { text: '', elapsedSeconds: 0, isRunning: false };
      }

      obj.nextStep.text = text;
      saveData();
    }

    // Auto-pause timer when switching objectives or closing app
    function autoPauseNextStepTimer() {
      const obj = data.objectives[selectedObjectiveIndex];
      if (obj?.nextStep?.isRunning) {
        pauseNextStepTimer();
      }
    }

    // Render next step section in content view
    function renderContentNextStep(container, obj) {
      const header = document.createElement('div');
      header.className = 'section-header';
      header.textContent = 'NEXT STEP';
      container.appendChild(header);

      // Initialize nextStep if needed
      if (!obj.nextStep) {
        obj.nextStep = { text: '', elapsedSeconds: 0, isRunning: false };
      }

      const item = document.createElement('div');
      item.className = 'next-step-item';

      // Checkbox
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'next-step-checkbox';
      checkbox.onchange = () => {
        if (checkbox.checked) {
          completeNextStep();
        }
      };
      item.appendChild(checkbox);

      // Editable content
      const content = document.createElement('span');
      content.className = 'next-step-content';
      content.contentEditable = 'true';
      content.spellcheck = false;
      content.dataset.placeholder = 'What do you want to do next?';
      content.textContent = obj.nextStep.text || '';

      // Enable spellcheck on focus
      content.onfocus = () => {
        content.spellcheck = true;
      };

      // Debounced save on input
      let saveTimeout = null;
      content.oninput = () => {
        if (saveTimeout) clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          saveNextStepText(content.textContent);
        }, 500);
      };

      // Save immediately on blur and disable spellcheck
      content.onblur = () => {
        if (saveTimeout) clearTimeout(saveTimeout);
        saveNextStepText(content.textContent);
        content.spellcheck = false;
      };

      item.appendChild(content);

      // Meta area (timer + play button)
      const meta = document.createElement('span');
      meta.className = 'next-step-meta';

      // Timer display
      const timer = document.createElement('span');
      timer.className = 'next-step-timer';
      if (obj.nextStep.isRunning) timer.classList.add('running');
      timer.textContent = formatTimerDisplay(obj.nextStep.elapsedSeconds);
      meta.appendChild(timer);

      // Edit button (shows on hover)
      const editBtn = document.createElement('button');
      editBtn.className = 'next-step-edit-btn';
      editBtn.textContent = 'edit';
      editBtn.onclick = (e) => {
        e.preventDefault();
        content.focus();
      };
      meta.appendChild(editBtn);

      // Play/Pause button (CSS handles the icon via ::before)
      const playBtn = document.createElement('button');
      playBtn.className = 'next-step-play-btn';
      if (obj.nextStep.isRunning) playBtn.classList.add('running');
      playBtn.onclick = (e) => {
        e.preventDefault();
        toggleNextStepTimer();
      };
      meta.appendChild(playBtn);

      item.appendChild(meta);
      container.appendChild(item);

      // Restart interval if timer was running
      if (obj.nextStep.isRunning && !nextStepTimerInterval) {
        nextStepTimerInterval = setInterval(() => {
          if (obj.nextStep && obj.nextStep.isRunning) {
            obj.nextStep.elapsedSeconds++;
            updateNextStepTimerDisplay(obj);
          }
        }, 1000);
      }
    }

    // Render steps section in content view
    function renderContentSteps(container, obj) {
      const header = document.createElement('div');
      header.className = 'section-header';
      header.textContent = 'STEPS';
      container.appendChild(header);

      // Check if we're adding a step (step will be in the array already)
      const isAddingStep = promptMode === 'add' && promptTargetSection === 'steps';

      // Add step button at top (only show if not currently adding)
      if (!isAddingStep) {
        const addDiv = document.createElement('div');
        addDiv.className = 'add-option';
        addDiv.innerHTML = '+ Log a step';
        addDiv.onclick = () => startLogStep();
        container.appendChild(addDiv);
      }

      // Display steps newest-first
      for (let displayIdx = 0; displayIdx < obj.steps.length; displayIdx++) {
        const actualIdx = obj.steps.length - 1 - displayIdx;
        const step = obj.steps[actualIdx];

        if (promptMode === 'confirm' && promptTargetSection === 'steps' && promptTargetIndex === actualIdx) {
          const div = document.createElement('div');
          div.innerHTML = createConfirmRow(`Delete "${step.name}"?`);
          container.appendChild(div.firstElementChild);
          continue;
        }

        const timestamp = formatTimestamp(step.loggedAt);
        const durationStr = step.duration ? ` (${formatDuration(step.duration)})` : '';
        const orderNum = step.orderNumber || (actualIdx + 1);
        const isAdding = promptMode === 'add' && promptTargetSection === 'steps' && promptTargetIndex === actualIdx;
        const isEditing = promptMode === 'edit' && promptTargetSection === 'steps' && promptTargetIndex === actualIdx;
        const isInEditMode = isAdding || isEditing;

        const listItem = createListItem({
          icon: orderNum.toString(),
          iconClass: '',
          content: step.name,
          contentEditable: isInEditMode,
          meta: `<span class="step-timestamp">${timestamp}${durationStr}</span>`,
          metaClass: 'compact',
          selected: false
        });

        // Add data attributes for edit controller
        listItem.dataset.section = 'steps';
        listItem.dataset.index = actualIdx;

        // Add placeholder for new items
        if (isAdding) {
          const contentEl = listItem.querySelector('.list-item-content');
          if (contentEl) {
            contentEl.dataset.placeholder = 'What did you do?';
          }
        }

        container.appendChild(listItem);
      }
    }

    // Focus prompt input after render
    function focusPromptInput() {
      if (!promptMode) return;
      setTimeout(() => {
        // Use specific selector to avoid grabbing next-step-content which is always contenteditable
        // Also check for sidebar objective input (.side-item-name)
        const contentEditable = document.querySelector('.list-item-content[contenteditable="true"], .side-item-name[contenteditable="true"]');
        if (contentEditable) {
          contentEditable.focus();
          const range = document.createRange();
          const sel = window.getSelection();
          range.selectNodeContents(contentEditable);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
          contentEditable.addEventListener('blur', () => {
            // Skip if we're transitioning between edits (already saved manually)
            if (skipBlurHandler) {
              skipBlurHandler = false;
              return;
            }
            if (promptMode) processPromptInput(contentEditable.textContent);
          }, { once: true });
          return;
        }
        const input = document.querySelector('.prompt-input');
        if (input) {
          input.focus();
          const len = input.value.length;
          input.setSelectionRange(len, len);
          if (input.tagName === 'TEXTAREA') {
            autoResizeTextarea(input);
            input.addEventListener('input', () => autoResizeTextarea(input));
          }
          input.addEventListener('blur', () => {
            // Skip if we're transitioning between edits (already saved manually)
            if (skipBlurHandler) {
              skipBlurHandler = false;
              return;
            }
            if (promptMode) processPromptInput(input.value);
          }, { once: true });
        }
      }, 0);
    }

    // Main update function
    async function updateView() {
      await renderSideList();
      renderContentView();
      focusPromptInput();
      updateStatusBar();
    }

    // Legacy alias
    function updateList() {
      updateView();
    }

    // Show message toast
    function showMessage(text, duration = 1500) {
      const toast = document.getElementById('message-toast');
      toast.textContent = text;
      toast.style.display = 'block';
      setTimeout(() => { toast.style.display = 'none'; }, duration);
    }

    // Start add folder
    async function startAddFolder() {
      // Prompt for folder name
      const name = prompt('Folder name:');
      if (!name || !name.trim()) return;

      try {
        if (window.Objectiv?.Repository?.createFolder) {
          const folder = await window.Objectiv.Repository.createFolder({
            name: name.trim(),
            parentId: null,
            orderIndex: data.folders.length
          });
          console.log('Created folder:', folder);

          // Reload folders and refresh
          const folders = await window.Objectiv.Repository.loadAllFolders();
          data.folders = folders;

          // Expand the new folder
          const SideListState = window.Objectiv?.SideListState;
          if (SideListState) {
            SideListState.expandFolder(folder.id);
          }

          renderSideList();
        }
      } catch (err) {
        console.error('Failed to create folder:', err);
        alert('Failed to create folder: ' + err.message);
      }
    }

    // Start add objective
    function startAddObjective() {
      // Commit any current edit first
      commitEditInPlace();

      // Create placeholder objective
      const newObj = {
        id: generateId(),
        name: '',
        description: '',
        priorities: [],
        steps: []
      };
      data.objectives.push(newObj);

      // Set up edit mode for the new objective
      promptMode = 'add';
      promptStep = 0;
      promptTargetIndex = data.objectives.length - 1;
      promptTargetSection = 'objectives';
      promptData = { type: 'objective', item: newObj };
      selectedObjectiveIndex = promptTargetIndex;

      updateView();
    }

    // Start add priority (instant inline edit pattern)
    function startAddPriority() {
      // Commit any current edit first
      commitEditInPlace();

      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj || obj.priorities.length >= 3) return;

      // Create placeholder priority
      const newPriority = {
        id: generateId(),
        name: '',
        description: ''
      };
      obj.priorities.push(newPriority);

      // Set up edit mode for the new priority
      promptMode = 'add';
      promptStep = 0;
      promptTargetIndex = obj.priorities.length - 1;
      promptTargetSection = 'priorities';
      promptData = { type: 'priority', item: newPriority };

      renderContentView();
      focusPromptInput();
      updateStatusBar();
    }

    // Start log step (instant inline edit pattern)
    function startLogStep() {
      // Commit any current edit first
      commitEditInPlace();

      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj) return;

      // Calculate next order number
      const maxOrder = obj.steps.reduce((max, s) => Math.max(max, s.orderNumber || 0), 0);

      // Create placeholder step
      const newStep = {
        id: generateId(),
        name: '',
        loggedAt: new Date().toISOString(),
        orderNumber: maxOrder + 1
      };
      obj.steps.push(newStep);

      // Set up edit mode for the new step
      promptMode = 'add';
      promptStep = 0;
      promptTargetIndex = obj.steps.length - 1;
      promptTargetSection = 'steps';
      promptData = { type: 'step', item: newStep };

      renderContentView();
      focusPromptInput();
      updateStatusBar();
    }

    // Process prompt input
    function processPromptInput(value) {
      if (promptMode === 'add') {
        processAddStep(value);
      } else if (promptMode === 'edit') {
        processEditStep(value);
      } else if (promptMode === 'refine') {
        processRefineStep(value);
      }
    }

    // ========================================
    // UNIFIED INLINE ADD PATTERN
    // ========================================
    // To add instant inline editing to any list:
    // 1. In startAdd*(): Create placeholder item with empty name, add to array,
    //    set promptMode='add', promptTargetSection, promptTargetIndex,
    //    promptData={type:'yourType', item: newItem}
    // 2. In render*(): Check isAdding, make item contenteditable, add data-placeholder
    // 3. This function handles save (name set) or cancel (removed from array)
    // 4. cancelPrompt() handles cleanup if user presses Escape
    // ========================================
    function processAddStep(value) {
      // Handle inline add (item already exists as placeholder)
      if (promptData.item) {
        if (!value.trim()) {
          // Remove placeholder and cancel
          if (promptData.type === 'objective') {
            data.objectives.splice(promptTargetIndex, 1);
            selectedObjectiveIndex = Math.max(0, data.objectives.length - 1);
          } else if (promptData.type === 'priority') {
            const obj = data.objectives[selectedObjectiveIndex];
            if (obj) obj.priorities.splice(promptTargetIndex, 1);
          } else if (promptData.type === 'step') {
            const obj = data.objectives[selectedObjectiveIndex];
            if (obj) obj.steps.splice(promptTargetIndex, 1);
          }
          cancelPrompt();
          return;
        }
        promptData.item.name = value.trim();
        saveData();
        cancelPrompt();
        return;
      }

      // Legacy multi-step flow (fallback)
      if (promptStep === 0) {
        if (!value.trim()) {
          showMessage('Name is required');
          updateList();
          return;
        }
        promptData.name = value.trim();
        promptStep = 1;
        updateList();
      } else if (promptStep === 1) {
        promptData.description = value.trim();
        finishAdd();
      }
    }

    // Finish add (for priorities only now)
    function finishAdd() {
      const newItem = {
        id: generateId(),
        name: promptData.name,
        description: promptData.description || ''
      };

      if (promptData.type === 'priority') {
        const obj = data.objectives[selectedObjectiveIndex];
        if (obj) obj.priorities.push(newItem);
      }

      saveData();
      cancelPrompt();
    }

    // Process edit
    function processEditStep(value) {
      if (!value.trim()) {
        showMessage('Name is required');
        updateList();
        return;
      }
      promptData.newName = value.trim();
      finishEdit();
    }

    // Finish edit
    function finishEdit() {
      promptData.item.name = promptData.newName;
      saveData();
      cancelPrompt();
    }

    // Process refine
    function processRefineStep(value) {
      promptData.item.description = value.trim();
      saveData();
      cancelPrompt();
    }

    // Process confirm
    function processConfirm(confirmed) {
      if (confirmed && promptData.action === 'delete') {
        if (promptTargetSection === 'objectives') {
          data.objectives.splice(promptTargetIndex, 1);
          selectedObjectiveIndex = Math.min(selectedObjectiveIndex, data.objectives.length - 1);
          if (selectedObjectiveIndex < 0) selectedObjectiveIndex = 0;
        } else if (promptTargetSection === 'priorities') {
          const obj = data.objectives[selectedObjectiveIndex];
          if (obj) obj.priorities.splice(promptTargetIndex, 1);
        } else if (promptTargetSection === 'steps') {
          const obj = data.objectives[selectedObjectiveIndex];
          if (obj) obj.steps.splice(promptTargetIndex, 1);
        }
        saveData();
      }
      cancelPrompt();
    }

    // Cancel prompt
    function cancelPrompt() {
      // Skip any pending blur handlers since we're explicitly canceling
      skipBlurHandler = true;

      // Remove placeholder items if adding was cancelled
      if (promptMode === 'add' && promptData.item) {
        if (promptTargetSection === 'objectives') {
          const obj = data.objectives[promptTargetIndex];
          if (obj && !obj.name.trim()) {
            data.objectives.splice(promptTargetIndex, 1);
            selectedObjectiveIndex = Math.max(0, data.objectives.length - 1);
          }
        } else if (promptTargetSection === 'priorities') {
          const obj = data.objectives[selectedObjectiveIndex];
          if (obj && obj.priorities[promptTargetIndex] && !obj.priorities[promptTargetIndex].name.trim()) {
            obj.priorities.splice(promptTargetIndex, 1);
          }
        } else if (promptTargetSection === 'steps') {
          const obj = data.objectives[selectedObjectiveIndex];
          if (obj && obj.steps[promptTargetIndex] && !obj.steps[promptTargetIndex].name.trim()) {
            obj.steps.splice(promptTargetIndex, 1);
          }
        }
      }

      promptMode = null;
      promptStep = 0;
      promptData = {};
      promptTargetIndex = -1;
      promptTargetSection = null;
      updateView();
    }

    // Refresh view alias
    function refreshView() {
      updateView();
    }

    // ========================================
    // NOTCH SOUND - Disabled
    // ========================================
    function playNotch() {
      // Sound disabled
    }

    // ========================================
    // SCROLL-BASED SELECTION - BUTTERY SMOOTH
    // Visual feedback is instant, content loading is deferred
    // Variables declared at top: _contentLoadTimeout, _lastLoadedIndex, CONTENT_LOAD_DEBOUNCE
    // ========================================

    /**
     * Schedule content loading - debounced to run after scroll stops
     */
    function scheduleContentLoad(index) {
      // Cancel any pending load
      if (_contentLoadTimeout) {
        clearTimeout(_contentLoadTimeout);
      }

      // Schedule new load after scroll settles
      _contentLoadTimeout = setTimeout(() => {
        loadContentForIndex(index);
      }, CONTENT_LOAD_DEBOUNCE);
    }

    /**
     * Actually load content for the selected index
     * Only runs when scroll has stopped
     */
    function loadContentForIndex(index) {
      // Skip if we already loaded this item
      if (index === _lastLoadedIndex) return;
      _lastLoadedIndex = index;

      const SideListState = window.Objectiv?.SideListState;
      if (!SideListState) return;

      const selectedItem = SideListState.getSelectedItem();
      if (!selectedItem) return;

      if (selectedItem.type === SideListState.ItemType.OBJECTIVE) {
        selectedObjectiveIndex = selectedItem.index;
        viewMode = 'objective';
        selectedFilePath = null;
        renderContentView();
      } else if (selectedItem.type === SideListState.ItemType.FILE) {
        // selectFile already has its own debounce, call directly
        _selectFileActual(selectedItem.path, selectedItem.name);
      }
    }

    // Side list container reference
    const sideListItems = document.getElementById('side-list-items');

    // ========================================
    // SCROLL-SNAP BASED SELECTION
    // Dot and content both update instantly to match snap position
    // Desktop only - mobile uses tap-to-select
    // ========================================
    let _rafPending = false;

    if (sideListItems && !isMobile) {
      sideListItems.addEventListener('scroll', () => {
        if (_rafPending) return;
        _rafPending = true;

        requestAnimationFrame(() => {
          _rafPending = false;

          const SideListState = window.Objectiv?.SideListState;
          if (!SideListState) return;

          const items = sideListItems.querySelectorAll('.side-item');
          if (!items.length) return;

          // Find item closest to snap line
          const containerRect = sideListItems.getBoundingClientRect();
          const snapLineY = containerRect.top + (window.innerHeight * 0.30);

          let closestIdx = 0;
          let closestDistance = Infinity;

          items.forEach((item, idx) => {
            const itemRect = item.getBoundingClientRect();
            // Match scroll-snap-align: start - use top edge
            const distance = Math.abs(itemRect.top - snapLineY);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestIdx = idx;
            }
          });

          const prevIdx = SideListState.getSelectedIndex();
          if (closestIdx !== prevIdx) {
            // Update state
            SideListState.setSelectedIndex(closestIdx);

            // Update visual dot
            if (items[prevIdx]) items[prevIdx].classList.remove('selected');
            if (items[closestIdx]) items[closestIdx].classList.add('selected');

            // Update content immediately
            const itemData = SideListState.getItems()[closestIdx];
            if (itemData?.type === SideListState.ItemType.OBJECTIVE) {
              selectedObjectiveIndex = itemData.index;
              viewMode = 'objective';
              renderContentView();
            }

            playNotch();
          }
        });
      }, { passive: true });
    }

    // ========================================
    // UNIFIED EDIT CONTROLLER
    // Single mousedown handler as the decision point
    // ========================================

    /**
     * Commit current edit in-place without re-rendering
     * Returns: { needsRerender: boolean, removedElement: boolean }
     */
    function commitEditInPlace() {
      if (!promptMode || (promptMode !== 'edit' && promptMode !== 'add' && promptMode !== 'refine')) {
        return { needsRerender: false, removedElement: false };
      }

      // Use specific selector to avoid next-step-content which is always contenteditable
      const contentEditable = document.querySelector('.list-item-content[contenteditable="true"]');
      if (!contentEditable) {
        resetPromptState();
        return { needsRerender: false, removedElement: false };
      }

      const value = contentEditable.textContent.trim();
      const listItem = contentEditable.closest('.list-item') || contentEditable.closest('.side-item');
      let needsRerender = false;
      let removedElement = false;

      skipBlurHandler = true; // Prevent blur from double-processing

      if (promptMode === 'add' && promptData.item) {
        if (!value) {
          // Remove empty placeholder - needs re-render
          if (promptTargetSection === 'objectives') {
            data.objectives.splice(promptTargetIndex, 1);
            selectedObjectiveIndex = Math.max(0, data.objectives.length - 1);
          } else if (promptTargetSection === 'priorities') {
            const obj = data.objectives[selectedObjectiveIndex];
            if (obj) obj.priorities.splice(promptTargetIndex, 1);
          } else if (promptTargetSection === 'steps') {
            const obj = data.objectives[selectedObjectiveIndex];
            if (obj) obj.steps.splice(promptTargetIndex, 1);
          }
          needsRerender = true;
          removedElement = true;
        } else {
          // Save and restore in place
          promptData.item.name = value;
          saveData();
          restoreElementInPlace(contentEditable, listItem, value);
        }
      } else if (promptMode === 'edit' && promptData.item) {
        if (value) {
          promptData.item.name = value;
          saveData();
        }
        restoreElementInPlace(contentEditable, listItem, promptData.item.name);
      } else if (promptMode === 'refine' && promptData.item) {
        promptData.item.description = value;
        saveData();
        restoreElementInPlace(contentEditable, listItem, promptData.item.name);
      }

      resetPromptState();
      return { needsRerender, removedElement };
    }

    /**
     * Restore a list item element to non-editable state
     */
    function restoreElementInPlace(contentEditable, listItem, text) {
      contentEditable.removeAttribute('contenteditable');
      contentEditable.removeAttribute('spellcheck');
      contentEditable.textContent = text;
    }

    /**
     * Reset prompt state variables
     */
    function resetPromptState() {
      promptMode = null;
      promptStep = 0;
      promptData = {};
      promptTargetIndex = -1;
      promptTargetSection = null;
    }

    /**
     * Start editing a list item in-place (no re-render)
     */
    function startEditInPlace(section, index, listItemEl) {
      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj) return;

      let item;
      if (section === 'priorities') {
        item = obj.priorities[index];
      } else if (section === 'steps') {
        item = obj.steps[index];
      }
      if (!item) return;

      const contentSpan = listItemEl.querySelector('.list-item-content');
      if (!contentSpan) return;

      // Set up prompt state
      promptMode = 'edit';
      promptStep = 0;
      promptTargetIndex = index;
      promptTargetSection = section;
      promptData = { type: section === 'priorities' ? 'priority' : 'step', item };

      // Make element editable with spellcheck
      contentSpan.setAttribute('contenteditable', 'true');
      contentSpan.setAttribute('spellcheck', 'true');

      // Focus and place cursor at end
      contentSpan.focus();
      const range = document.createRange();
      const sel = window.getSelection();
      range.selectNodeContents(contentSpan);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);

      // Blur handler as fallback for edge cases (tabbing away, etc.)
      contentSpan.addEventListener('blur', () => {
        if (skipBlurHandler) {
          skipBlurHandler = false;
          return;
        }
        if (promptMode) {
          processPromptInput(contentSpan.textContent);
        }
      }, { once: true });

      updateStatusBar();
    }

    /**
     * Start editing the objective title in the content header
     */
    function startEditObjectiveTitle() {
      const obj = data.objectives[selectedObjectiveIndex];
      if (!obj) return;

      const titleEl = document.getElementById('content-header-title');
      if (!titleEl) return;

      // Don't start if already editing
      if (promptMode) return;

      // Set up prompt state
      promptMode = 'edit';
      promptStep = 0;
      promptTargetIndex = selectedObjectiveIndex;
      promptTargetSection = 'objectives';
      promptData = { type: 'objective', item: obj };

      // Make element editable with spellcheck
      titleEl.setAttribute('contenteditable', 'true');
      titleEl.setAttribute('spellcheck', 'true');

      // Focus and place cursor at end
      titleEl.focus();
      const range = document.createRange();
      const sel = window.getSelection();
      range.selectNodeContents(titleEl);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);

      // Blur handler as fallback
      titleEl.addEventListener('blur', () => {
        if (skipBlurHandler) {
          skipBlurHandler = false;
          return;
        }
        if (promptMode === 'edit' && promptTargetSection === 'objectives') {
          commitObjectiveTitleEdit();
        }
      }, { once: true });

      updateStatusBar();
    }

    /**
     * Commit objective title edit or add
     */
    function commitObjectiveTitleEdit() {
      if (promptTargetSection !== 'objectives') return;
      if (promptMode !== 'edit' && promptMode !== 'add') return;

      skipBlurHandler = true;

      if (promptMode === 'edit') {
        // Editing existing objective title in content header
        const titleEl = document.getElementById('content-header-title');
        if (!titleEl) return;

        const value = titleEl.textContent.trim();
        const obj = data.objectives[selectedObjectiveIndex];

        if (value && obj) {
          obj.name = value;
          saveData();
          // Also update sidebar
          renderSideList();
        } else if (obj) {
          // Restore original if empty
          titleEl.textContent = obj.name;
        }

        titleEl.removeAttribute('contenteditable');
        titleEl.removeAttribute('spellcheck');
      } else if (promptMode === 'add') {
        // Adding new objective in sidebar
        const sidebarInput = document.querySelector('.side-item-name[contenteditable="true"]');
        if (!sidebarInput) return;

        const value = sidebarInput.textContent.trim();

        if (value && promptData.item) {
          // Save the new objective
          promptData.item.name = value;
          saveData();
          renderSideList();
        } else {
          // Remove empty placeholder
          data.objectives.splice(promptTargetIndex, 1);
          selectedObjectiveIndex = Math.max(0, data.objectives.length - 1);
          renderSideList();
        }
      }

      resetPromptState();
      updateStatusBar();
    }

    /**
     * Main mousedown handler - single decision point for all edit interactions
     */
    document.addEventListener('mousedown', (e) => {
      // Skip confirm mode - has its own keyboard handling
      if (promptMode === 'confirm') return;

      const currentEditable = document.querySelector('[contenteditable="true"]');
      const clickedListItem = e.target.closest('.list-item[data-section]');
      const clickedSideItem = e.target.closest('.side-item:not(.add-option)');
      const clickedAddOption = e.target.closest('.add-option');
      const clickedTitle = e.target.closest('#content-header-title');

      // CASE 1: Not currently editing - just let clicks proceed normally
      if (!currentEditable || !promptMode) {
        // If clicking the objective title, start editing it
        if (clickedTitle && data.objectives.length > 0) {
          e.preventDefault();
          startEditObjectiveTitle();
          return;
        }
        // If clicking a list item, start editing it
        if (clickedListItem) {
          e.preventDefault();
          const section = clickedListItem.dataset.section;
          const index = parseInt(clickedListItem.dataset.index, 10);
          if (section && !isNaN(index)) {
            startEditInPlace(section, index, clickedListItem);
          }
        }
        // Side items and add options have their own handlers
        return;
      }

      // Currently editing the title - clicking on it should continue editing
      if (clickedTitle && promptTargetSection === 'objectives') {
        return;
      }

      // CASE 2: Currently editing - determine what to do
      const currentItem = currentEditable.closest('.list-item') || currentEditable.closest('.side-item');

      // Clicking on the same item being edited - do nothing, let editing continue
      if (currentItem && currentItem.contains(e.target)) {
        return;
      }

      // CASE 3: Clicking on a different list item - transition edit
      if (clickedListItem) {
        e.preventDefault();
        const section = clickedListItem.dataset.section;
        const index = parseInt(clickedListItem.dataset.index, 10);

        // Handle objective title edit specially
        if (promptTargetSection === 'objectives') {
          commitObjectiveTitleEdit();
          startEditInPlace(section, index, clickedListItem);
          return;
        }

        // Commit current edit in place
        const { needsRerender, removedElement } = commitEditInPlace();

        if (needsRerender) {
          // Element was removed, need to re-render then start edit
          // Adjust index if we removed an item before the target
          let adjustedIndex = index;
          if (removedElement && promptTargetSection === section && promptTargetIndex < index) {
            adjustedIndex = index - 1;
          }
          updateView();
          // Find the new element and start editing
          setTimeout(() => {
            const newListItem = document.querySelector(`.list-item[data-section="${section}"][data-index="${adjustedIndex}"]`);
            if (newListItem) {
              startEditInPlace(section, adjustedIndex, newListItem);
            }
          }, 0);
        } else {
          // No re-render needed - start editing directly
          startEditInPlace(section, index, clickedListItem);
        }
        return;
      }

      // CASE 4: Clicking on add option - commit and let add handler run
      if (clickedAddOption) {
        // Handle objective title edit specially
        if (promptTargetSection === 'objectives') {
          commitObjectiveTitleEdit();
        } else {
          const { needsRerender } = commitEditInPlace();
          if (needsRerender) {
            updateView();
          }
        }
        // Let the click event proceed to the add option's onclick
        return;
      }

      // CASE 5: Clicking on side item - commit and let selection happen
      if (clickedSideItem) {
        // Handle objective title edit specially
        if (promptTargetSection === 'objectives') {
          commitObjectiveTitleEdit();
        } else {
          const { needsRerender } = commitEditInPlace();
          if (needsRerender) {
            updateView();
          }
        }
        // Let the click event proceed to select the objective
        return;
      }

      // CASE 6: Clicking elsewhere (empty space) - just commit and close
      // Handle objective title edit specially
      if (promptTargetSection === 'objectives') {
        commitObjectiveTitleEdit();
      } else {
        const { needsRerender } = commitEditInPlace();
        if (needsRerender) {
          updateView();
        }
      }
      updateStatusBar();
    });

    // Keyboard handling (simplified for split-pane)
    document.addEventListener('keydown', (e) => {
      // Handle prompt input
      if (promptMode === 'add' || promptMode === 'edit' || promptMode === 'refine') {
        // Special handling for objective title editing/adding
        if ((promptMode === 'edit' || promptMode === 'add') && promptTargetSection === 'objectives') {
          if (e.key === 'Escape') {
            e.preventDefault();
            if (promptMode === 'edit') {
              // Restore original and cancel
              const titleEl = document.getElementById('content-header-title');
              const obj = data.objectives[selectedObjectiveIndex];
              if (titleEl && obj) {
                titleEl.textContent = obj.name;
                titleEl.removeAttribute('contenteditable');
                titleEl.removeAttribute('spellcheck');
              }
            } else if (promptMode === 'add') {
              // Remove placeholder objective
              data.objectives.splice(promptTargetIndex, 1);
              selectedObjectiveIndex = Math.max(0, data.objectives.length - 1);
              renderSideList();
            }
            resetPromptState();
            updateStatusBar();
            return;
          }
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            commitObjectiveTitleEdit();
            return;
          }
          return;
        }

        if (e.key === 'Escape') {
          e.preventDefault();
          cancelPrompt();
          return;
        }
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          // Use specific selector to avoid next-step-content
          const contentEditable = document.querySelector('.list-item-content[contenteditable="true"]');
          if (contentEditable) {
            processPromptInput(contentEditable.textContent);
            return;
          }
          const input = document.querySelector('.prompt-input');
          if (input) processPromptInput(input.value);
          return;
        }
        return;
      }

      // Handle confirm
      if (promptMode === 'confirm') {
        if (e.key === 'y' || e.key === 'Y') {
          e.preventDefault();
          processConfirm(true);
          return;
        }
        if (e.key === 'n' || e.key === 'N' || e.key === 'Escape') {
          e.preventDefault();
          processConfirm(false);
          return;
        }
        return;
      }
    });

    // Edit button click handler (event delegation)
    document.getElementById('content-body').addEventListener('click', (e) => {
      if (e.target.classList.contains('edit-btn')) {
        e.stopPropagation();
        const section = e.target.dataset.section;
        const index = parseInt(e.target.dataset.index, 10);
        promptTargetIndex = index;
        promptTargetSection = section;

        if (section === 'priorities') {
          const obj = data.objectives[selectedObjectiveIndex];
          if (obj && obj.priorities[index]) {
            promptMode = 'edit';
            promptData = { type: 'priority', item: obj.priorities[index] };
            updateView();
          }
        }
      }
    });

    // Update status bar
    function updateStatusBar() {
      let shortcuts = '';
      if (promptMode) {
        shortcuts = '[Enter] Confirm  [Esc] Cancel';
      }
      document.getElementById('shortcuts').textContent = shortcuts;
    }

    // Initialize
    async function init() {
      await showIntro();

      const FolderExplorer = window.Objectiv?.FolderExplorer;
      const SideListState = window.Objectiv?.SideListState;
      const Repository = window.Objectiv?.Repository;

      // Ensure demo mode is disabled
      if (FolderExplorer) {
        FolderExplorer.setDemoMode?.(false);
      }

      // Check if a vault was previously selected (persisted in localStorage)
      const hasVault = SideListState?.getRootPath?.();

      if (hasVault) {
        // Vault already selected - load objectives from it
        if (Repository) {
          data = await Repository.initializeData();
        }

        // Set initial view state based on loaded data
        if (data.objectives.length > 0) {
          selectedObjectiveIndex = 0;
          viewMode = 'objective';
        } else {
          selectedObjectiveIndex = -1;
          viewMode = 'empty';
        }
      } else {
        // No vault selected - show vault-first UI
        // The SideListState.rebuildItems() will show only "Select your folder"
        viewMode = 'empty';
        selectedObjectiveIndex = -1;
      }

      updateView();
    }

    // Auto-pause timer when closing browser/app
    window.addEventListener('beforeunload', () => {
      autoPauseNextStepTimer();
    });

    init();
  </script>
</body>
</html>
